#!/usr/bin/env python3

"""
Comprehensive Plotting Script for Dynamic Quantum Walk Experiment Data

This script loads and plots data generated by the dynamic sample generation, probability distribution recreation,
standard deviation generation, and survival probability generation scripts.

Key Features:
- Loads data from dynamic experiment directory structure
- Creates three main plot types: standard deviation vs time, final probability distributions, survival probabilities
- Configurable plot parameters and output formats
- Support for multiple plot scales (linear, log-log, semi-log)
- Smart data loading with flexible directory format support for dynamic experiments

Usage:
    python plot_dynamic_experiment_results.py

Configuration:
    Edit the parameters section below to match your dynamic experiment setup and plotting preferences.
"""

import os
import sys
import time
import pickle
import logging
import math
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# ============================================================================
# CONFIGURATION PARAMETERS
# ============================================================================

# Experiment parameters - EDIT THESE TO MATCH YOUR SETUP
N = 20000              # System size (production scale for cluster)
steps = N//4           # Time steps (5000 for N=20000)
samples = 40           # Samples per deviation (full production count)
base_theta = math.pi/3  # Base theta parameter for dynamic angle noise

# # Experiment parameters - EDIT THESE TO MATCH YOUR SETUP
# N = 100              # System size (production scale for cluster)
# steps = N//4           # Time steps (5000 for N=20000)
# samples = 1          # Samples per deviation (full production count)
# base_theta = math.pi/3 # Base theta parameter for dynamic angle noise


# Deviation values - Dynamic noise format (angle deviations) - Matching original static experiment
devs = [
    0,                  # No noise (equivalent to (0,0))
    0.2,                # Small noise (equivalent to (0, 0.2))
    0.6,                # Medium noise (equivalent to (0, 0.6))
    0.8,                # Medium noise (equivalent to (0, 0.8))
    1.0,                # Large noise (equivalent to (0, 1))
]

# Directory configuration (matching the dynamic generation scripts)
PROBDIST_BASE_DIR = "experiments_data_samples_dynamic_probDist"
STD_BASE_DIR = "experiments_data_samples_dynamic_std"
SURVIVAL_BASE_DIR = "experiments_data_samples_dynamic_survival"

# Figure save path
FIG_SAVE_PATH = "plot_dynamic_experiments_fig"

# Global plotting control
ENABLE_PLOTTING = True  # Master switch for all plotting

# Standard Deviation vs Time Plot Configuration
STD_PLOT_CONFIG = {
    'enabled': True,                    # Enable/disable this specific plot
    'use_loglog': True,                 # Use log-log scale instead of linear
    'figure_size': (12, 8),            # Figure size in inches (width, height)
    'save_figure': True,                # Save plot to file
    'filename_linear': 'dynamic_std_vs_time_N{N}_steps{steps}_samples{samples}_basetheta{basetheta:.3f}.png',
    'filename_loglog': 'dynamic_std_vs_time_loglog_N{N}_steps{steps}_samples{samples}_basetheta{basetheta:.3f}.png',
    'title_linear': 'Dynamic Standard Deviation vs Time (base θ={basetheta:.3f})',
    'title_loglog': 'Dynamic Standard Deviation vs Time - Log Scale (base θ={basetheta:.3f})',
    'xlabel': 'Time Step',
    'ylabel': 'Standard Deviation',
    'fontsize_title': 14,
    'fontsize_labels': 12,
    'fontsize_legend': 10,
    'linewidth': 2,
    'markersize': 0,
    'marker_circle': 'o',
    'marker_square': 's',
    'marker_square_size': 4,
    'linestyle_noiseless': '--',
    'alpha_noiseless': 0.8,
    'alpha_regular': 1.0,
    'grid_alpha': 0.3,
    'grid_which': 'both',               # For log-log: 'both', 'major', 'minor'
    'grid_linestyle': '-',
    'epsilon_noiseless': 1e-3,          # Small value for noiseless case in log-log
    'dpi': 300,                         # DPI for saved figures
    'bbox_inches': 'tight'              # Bbox setting for saved figures
}

# Final Probability Distribution Plot Configuration  
PROBDIST_PLOT_CONFIG = {
    'enabled': True,                    # Enable/disable this specific plot
    'figure_size': (14, 8),            # Figure size in inches (width, height)
    'save_figure': True,                # Save plot to file
    'filename': 'dynamic_final_probdist_log_N{N}_steps{steps}_samples{samples}_basetheta{basetheta:.3f}.png',
    'title': 'Dynamic Final Probability Distribution (t={final_step}, base θ={basetheta:.3f})',
    'xlabel': 'Position',
    'ylabel': 'Probability (log scale)',
    'fontsize_title': 14,
    'fontsize_labels': 12,
    'fontsize_legend': 10,
    'linewidth': 2,
    'alpha': 0.8,
    'xlim': (-500, 500),                 # X-axis limits
    'ylim_min': 1e-5,                  # Y-axis minimum (None for auto)
    'ylim_max': 1e0,                   # Y-axis maximum (None for auto)
    'grid_alpha': 0.3,
    'dpi': 300,                        # DPI for saved figures
    'bbox_inches': 'tight'             # Bbox setting for saved figures
}

# Survival Probability Plot Configuration
SURVIVAL_PLOT_CONFIG = {
    'enabled': True,                    # Enable/disable this specific plot
    'use_loglog': True,                # Use log-log scale instead of linear
    'use_semilogy': False,              # Use log-linear (semilogy) scale
    'figure_size': (12, 8),            # Figure size in inches (width, height)
    'save_figure': True,                # Save plot to file
    'filename_linear': 'dynamic_survival_prob_linear_N{N}_steps{steps}_samples{samples}_basetheta{basetheta:.3f}.png',
    'filename_loglog': 'dynamic_survival_prob_loglog_N{N}_steps{steps}_samples{samples}_basetheta{basetheta:.3f}.png',
    'filename_semilogy': 'dynamic_survival_prob_semilogy_N{N}_steps{steps}_samples{samples}_basetheta{basetheta:.3f}.png',
    'title_linear': 'Dynamic Survival Probability vs Time (base θ={basetheta:.3f})',
    'title_loglog': 'Dynamic Survival Probability vs Time - Log Scale (base θ={basetheta:.3f})',
    'title_semilogy': 'Dynamic Survival Probability vs Time - Semi-Log Scale (base θ={basetheta:.3f})',
    'xlabel': 'Time Step',
    'ylabel_linear': 'Survival Probability',
    'ylabel_loglog': 'Survival Probability (log scale)',
    'ylabel_semilogy': 'Survival Probability (log scale)',
    'fontsize_title': 14,
    'fontsize_labels': 12,
    'fontsize_legend': 10,
    'linewidth': 2,
    'markersize': 0,
    'alpha_regular': 1.0,
    'grid_alpha': 0.3,
    'grid_which': 'both',               # For log-log: 'both', 'major', 'minor'
    'grid_linestyle': '-',
    'dpi': 300,                         # DPI for saved figures
    'bbox_inches': 'tight',             # Bbox setting for saved figures
    'survival_range': 'range_80_80'     # Default survival range to plot
}

# Label formatting configuration
LABEL_CONFIG = {
    'precision_new_format': 3,          # Decimal places for new format labels
    'precision_legacy_format': 3,       # Decimal places for legacy format labels
    'precision_single_value': 3,        # Decimal places for single value labels
    'plot_label_template': 'Dynamic deviation = {dev_label}'
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def dummy_tesselation_func(N):
    """Dummy tessellation function for dynamic noise (tessellations are built-in)"""
    return None

def format_deviation_label(dev):
    """
    Format deviation values for plot labels.
    """
    if dev == 0:
        return "0.000"
    else:
        return f"{float(dev):.6f}"

def get_dynamic_experiment_dir(N, base_theta, deviation, base_dir="experiments_data_samples_dynamic", samples=None):
    """
    Get dynamic experiment directory path with proper structure.
    
    Structure: base_dir/dynamic_angle_noise/[noise|no_noise]/basetheta_X/dev_X/N_X/
    Example: experiments_data_samples_dynamic_probDist/dynamic_angle_noise/noise/basetheta_1p047198/dev_0p523599/N_100/
    Note: Decimal points are replaced with 'p' in directory names
    """
    # Determine if there's noise
    has_noise = deviation > 0
    
    # Create the main experiment directory structure
    exp_base = os.path.join(base_dir, "dynamic_angle_noise")
    
    # Add noise subdirectory
    if has_noise:
        noise_dir = os.path.join(exp_base, "noise")
    else:
        noise_dir = os.path.join(exp_base, "no_noise")
    
    # Add base theta information (replace decimal points with 'p')
    theta_str = f"basetheta_{base_theta:.6f}".replace(".", "p")
    theta_dir = os.path.join(noise_dir, theta_str)
    
    # Add deviation-specific directory (replace decimal points with 'p')
    dev_rounded = round(deviation, 6)
    dev_str = f"dev_{dev_rounded:.6f}".replace(".", "p")
    dev_dir = os.path.join(theta_dir, dev_str)
    
    # Add N-specific directory
    final_dir = os.path.join(dev_dir, f"N_{N}")
    
    return final_dir

def find_dynamic_experiment_dir_flexible(N, base_theta, deviation, base_dir="experiments_data_samples_dynamic", samples=None):
    """
    Find dynamic experiment directory with flexible format matching.
    Tries different directory structures to find existing data.
    """
    # Try with the correct dynamic structure
    exp_dir = get_dynamic_experiment_dir(N, base_theta, deviation, base_dir, samples)
    if os.path.exists(exp_dir):
        return exp_dir, "dynamic_format"
    
    # If nothing found, return the target path (will be created if needed)
    return get_dynamic_experiment_dir(N, base_theta, deviation, base_dir, samples), "dynamic_format"

# ============================================================================
# DATA LOADING FUNCTIONS
# ============================================================================

def load_dynamic_std_data_directly(devs, N, base_theta, std_base_dir, samples=None):
    """
    Load standard deviation data directly from dynamic std files.
    """
    print(f"\n[DATA] Loading dynamic standard deviation data from '{std_base_dir}'...")
    
    stds = []
    
    for i, dev in enumerate(devs):
        exp_dir, format_type = find_dynamic_experiment_dir_flexible(
            N, base_theta, dev, base_dir=std_base_dir, samples=samples
        )
        
        std_file = os.path.join(exp_dir, "std_vs_time.pkl")
        
        try:
            if os.path.exists(std_file):
                with open(std_file, 'rb') as f:
                    std_data = pickle.load(f)
                stds.append(std_data)
                print(f"  Dev {format_deviation_label(dev)}: {len(std_data)} time steps")
            else:
                print(f"  Dev {format_deviation_label(dev)}: file not found - {std_file}")
                stds.append([])
        except Exception as e:
            print(f"  Dev {format_deviation_label(dev)}: load error - {e}")
            stds.append([])
    
    print(f"[OK] Dynamic standard deviation data loading completed!")
    return stds

def load_dynamic_final_step_probability_distributions(N, base_theta, steps, parameter_list, probdist_base_dir, samples=None):
    """
    Load only the final step probability distributions from the dynamic probDist folder.
    """
    final_step = steps - 1
    print(f"\n[DATA] Loading dynamic final step probability distributions (step {final_step}) from '{probdist_base_dir}'...")
    
    results = []
    for i, dev in enumerate(parameter_list):
        exp_dir, format_type = find_dynamic_experiment_dir_flexible(
            N, base_theta, dev, base_dir=probdist_base_dir, samples=samples
        )
        
        prob_file = os.path.join(exp_dir, f"mean_step_{final_step}.pkl")
        
        try:
            if os.path.exists(prob_file):
                with open(prob_file, 'rb') as f:
                    prob_data = pickle.load(f)
                results.append(prob_data)
                print(f"  Dev {format_deviation_label(dev)}: loaded final step distribution")
            else:
                print(f"  Dev {format_deviation_label(dev)}: file not found - {prob_file}")
                results.append(None)
        except Exception as e:
            print(f"  Dev {format_deviation_label(dev)}: load error - {e}")
            results.append(None)
    
    print(f"[OK] Dynamic final step probability distribution loading completed!")
    return results

def load_dynamic_survival_probability_data(devs, N, base_theta, survival_base_dir, survival_range="center", samples=None):
    """
    Load survival probability data directly from dynamic survival probability files.
    """
    print(f"\n[DATA] Loading dynamic survival probability data from '{survival_base_dir}'...")
    print(f"[DATA] Target survival range: {survival_range}")
    
    survival_probs = []
    
    for i, dev in enumerate(devs):
        exp_dir, format_type = find_dynamic_experiment_dir_flexible(
            N, base_theta, dev, base_dir=survival_base_dir, samples=samples
        )
        
        survival_file = os.path.join(exp_dir, "survival_vs_time.pkl")
        
        try:
            if os.path.exists(survival_file):
                with open(survival_file, 'rb') as f:
                    survival_data = pickle.load(f)
                
                # Extract data for the requested range
                if isinstance(survival_data, dict) and survival_range in survival_data:
                    range_data = survival_data[survival_range]
                    survival_probs.append(range_data)
                    print(f"  Dev {format_deviation_label(dev)}: {len(range_data)} time steps for range '{survival_range}'")
                else:
                    print(f"  Dev {format_deviation_label(dev)}: range '{survival_range}' not found in data")
                    survival_probs.append([])
            else:
                print(f"  Dev {format_deviation_label(dev)}: file not found - {survival_file}")
                survival_probs.append([])
        except Exception as e:
            print(f"  Dev {format_deviation_label(dev)}: load error - {e}")
            survival_probs.append([])
    
    print(f"[OK] Dynamic survival probability data loading completed!")
    return survival_probs

# ============================================================================
# PLOTTING FUNCTIONS
# ============================================================================

def plot_dynamic_standard_deviation_vs_time(stds, devs, steps):
    """
    Plot standard deviation vs time for different dynamic noise deviations.
    """
    config = STD_PLOT_CONFIG
    if not ENABLE_PLOTTING or not config['enabled']:
        print("\n[PLOT] Dynamic standard deviation plotting disabled")
        return
    
    print("\n[PLOT] Creating dynamic standard deviation vs time plot...")
    try:
        if len(stds) > 0 and any(len(s) > 0 for s in stds):
            plt.figure(figsize=config['figure_size'])
            
            for i, (std_values, dev) in enumerate(zip(stds, devs)):
                if len(std_values) > 0:
                    time_steps = list(range(len(std_values)))
                    dev_label = format_deviation_label(dev)
                    plot_label = LABEL_CONFIG['plot_label_template'].format(dev_label=dev_label)
                    
                    if config['use_loglog']:
                        # Remove zero values which can't be plotted on log scale
                        filtered_data = [(t, s) for t, s in zip(time_steps, std_values) if t > 0 and s > 0]
                        if filtered_data:
                            filtered_times, filtered_stds = zip(*filtered_data)
                            
                            # Special styling for noiseless case
                            if dev == 0:
                                plt.loglog(filtered_times, filtered_stds, 
                                         label=f'{plot_label} (noiseless)', 
                                         linewidth=config['linewidth'], 
                                         linestyle=config['linestyle_noiseless'], alpha=config['alpha_noiseless'])
                            else:
                                plt.loglog(filtered_times, filtered_stds, 
                                         label=plot_label, 
                                         marker=config['marker_circle'], markersize=config['markersize'], 
                                         linewidth=config['linewidth'], alpha=config['alpha_regular'])
                    else:
                        plt.plot(time_steps, std_values, 
                               label=plot_label, 
                               marker=config['marker_circle'], markersize=config['markersize'], 
                               linewidth=config['linewidth'], alpha=config['alpha_regular'])
            
            plt.xlabel(config['xlabel'], fontsize=config['fontsize_labels'])
            plt.ylabel(config['ylabel'], fontsize=config['fontsize_labels'])
            
            if config['use_loglog']:
                plt.title(config['title_loglog'].format(basetheta=base_theta), fontsize=config['fontsize_title'])
                plt.grid(True, alpha=config['grid_alpha'], which=config['grid_which'], 
                        linestyle=config['grid_linestyle'])
                plot_filename = config['filename_loglog'].format(N=N, steps=steps, samples=samples, basetheta=base_theta)
            else:
                plt.title(config['title_linear'].format(basetheta=base_theta), fontsize=config['fontsize_title'])
                plt.grid(True, alpha=config['grid_alpha'])
                plot_filename = config['filename_linear'].format(N=N, steps=steps, samples=samples, basetheta=base_theta)
            
            plt.legend(fontsize=config['fontsize_legend'])
            plt.tight_layout()
            
            # Save the plot (if enabled)
            if config['save_figure']:
                # Ensure the figure save directory exists
                os.makedirs(FIG_SAVE_PATH, exist_ok=True)
                full_plot_path = os.path.join(FIG_SAVE_PATH, plot_filename)
                plt.savefig(full_plot_path, dpi=config['dpi'], bbox_inches=config['bbox_inches'])
                print(f"[OK] Plot saved as '{full_plot_path}'")
            
            # Show the plot
            plt.show()
            plot_type = "log-log" if config['use_loglog'] else "linear"
            saved_status = " and saved" if config['save_figure'] else ""
            print(f"[OK] Dynamic standard deviation plot displayed{saved_status}! (Scale: {plot_type})")
        else:
            print("[WARNING] No dynamic standard deviation data available for plotting")
    except Exception as e:
        print(f"[WARNING] Could not create plot: {e}")
        import traceback
        traceback.print_exc()

def plot_dynamic_final_probability_distributions(final_results, devs, steps, N):
    """
    Plot final probability distributions for different dynamic noise deviations.
    """
    config = PROBDIST_PLOT_CONFIG
    if not ENABLE_PLOTTING or not config['enabled']:
        print("\n[PLOT] Dynamic final probability distribution plotting disabled")
        return
    
    print("\n[PLOT] Creating dynamic final probability distribution plot...")
    try:
        if final_results and len(final_results) > 0:
            plt.figure(figsize=config['figure_size'])
            
            # Use the last time step (steps-1)
            final_step = steps - 1
            domain = np.arange(N) - N//2  # Center domain around 0
            
            for i, (final_prob_dist, dev) in enumerate(zip(final_results, devs)):
                if final_prob_dist is not None:
                    final_prob_dist = final_prob_dist.flatten()
                    
                    dev_label = format_deviation_label(dev)
                    plot_label = LABEL_CONFIG['plot_label_template'].format(dev_label=dev_label)
                    
                    # Plot the probability distribution with log y-axis
                    plt.semilogy(domain, final_prob_dist, 
                               label=plot_label, 
                               linewidth=config['linewidth'], alpha=config['alpha'])
            
            plt.xlabel(config['xlabel'], fontsize=config['fontsize_labels'])
            plt.ylabel(config['ylabel'], fontsize=config['fontsize_labels'])
            plt.title(config['title'].format(final_step=final_step, basetheta=base_theta), fontsize=config['fontsize_title'])
            
            # Set axis limits based on config
            if config['xlim']:
                plt.xlim(config['xlim'])
            if config['ylim_min'] is not None or config['ylim_max'] is not None:
                plt.ylim(config['ylim_min'], config['ylim_max'])
            
            plt.legend(fontsize=config['fontsize_legend'])
            plt.grid(True, alpha=config['grid_alpha'])
            plt.tight_layout()
            
            # Save the plot (if enabled)
            if config['save_figure']:
                # Ensure the figure save directory exists
                os.makedirs(FIG_SAVE_PATH, exist_ok=True)
                plot_filename = config['filename'].format(N=N, steps=steps, samples=samples, basetheta=base_theta)
                full_plot_path = os.path.join(FIG_SAVE_PATH, plot_filename)
                plt.savefig(full_plot_path, dpi=config['dpi'], bbox_inches=config['bbox_inches'])
                print(f"[OK] Dynamic probability distribution plot saved as '{full_plot_path}'")
            
            # Show the plot
            plt.show()
            saved_status = " and saved" if config['save_figure'] else ""
            print(f"[OK] Dynamic final probability distribution plot displayed{saved_status}!")
        else:
            print("[WARNING] No dynamic probability distribution data available for plotting")
    except Exception as e:
        print(f"[WARNING] Could not create dynamic probability distribution plot: {e}")
        import traceback
        traceback.print_exc()

def plot_dynamic_survival_probabilities(survival_probs, devs, steps, survival_range="center"):
    """
    Plot survival probabilities vs time for different dynamic noise deviations.
    """
    config = SURVIVAL_PLOT_CONFIG
    if not ENABLE_PLOTTING or not config['enabled']:
        print("\n[PLOT] Dynamic survival probability plotting disabled")
        return
    
    print(f"\n[PLOT] Creating dynamic survival probability vs time plot for range '{survival_range}'...")
    try:
        if len(survival_probs) > 0 and any(len(sp) > 0 for sp in survival_probs):
            # Determine which plot types to create
            plot_types = []
            if not config['use_loglog'] and not config['use_semilogy']:
                plot_types.append('linear')
            if config['use_semilogy']:
                plot_types.append('semilogy')
            if config['use_loglog']:
                plot_types.append('loglog')
            
            for plot_type in plot_types:
                plt.figure(figsize=config['figure_size'])
                
                for i, (survival_values, dev) in enumerate(zip(survival_probs, devs)):
                    if len(survival_values) > 0:
                        time_steps = list(range(len(survival_values)))
                        
                        dev_label = format_deviation_label(dev)
                        plot_label = LABEL_CONFIG['plot_label_template'].format(dev_label=dev_label)
                        
                        # Plot based on type
                        if plot_type == 'linear':
                            # Filter out None values even for linear scale
                            filtered_data = [(t, s) for t, s in zip(time_steps, survival_values) if s is not None]
                            if filtered_data:
                                filtered_times, filtered_survival = zip(*filtered_data)
                                plt.plot(filtered_times, filtered_survival, 
                                       label=plot_label, 
                                       linewidth=config['linewidth'], 
                                       alpha=config['alpha_regular'])
                        elif plot_type == 'semilogy':
                            # Filter out zero/negative/None values for log scale
                            filtered_data = [(t, s) for t, s in zip(time_steps, survival_values) if s is not None and s > 0]
                            if filtered_data:
                                filtered_times, filtered_survival = zip(*filtered_data)
                                plt.semilogy(filtered_times, filtered_survival, 
                                           label=plot_label, 
                                           linewidth=config['linewidth'], 
                                           alpha=config['alpha_regular'])
                        elif plot_type == 'loglog':
                            # Filter out zero/negative/None values for log scale
                            filtered_data = [(t, s) for t, s in zip(time_steps, survival_values) if t > 0 and s is not None and s > 0]
                            if filtered_data:
                                filtered_times, filtered_survival = zip(*filtered_data)
                                plt.loglog(filtered_times, filtered_survival, 
                                         label=plot_label, 
                                         linewidth=config['linewidth'], 
                                         alpha=config['alpha_regular'])
                
                # Set labels and title based on plot type
                if plot_type == 'linear':
                    plt.xlabel(config['xlabel'], fontsize=config['fontsize_labels'])
                    plt.ylabel(config['ylabel_linear'], fontsize=config['fontsize_labels'])
                    plt.title(config['title_linear'].format(basetheta=base_theta) + f" - {survival_range.replace('_', ' ').title()}", 
                             fontsize=config['fontsize_title'])
                    plot_filename = config['filename_linear'].format(N=N, steps=steps, samples=samples, basetheta=base_theta)
                elif plot_type == 'semilogy':
                    plt.xlabel(config['xlabel'], fontsize=config['fontsize_labels'])
                    plt.ylabel(config['ylabel_semilogy'], fontsize=config['fontsize_labels'])
                    plt.title(config['title_semilogy'].format(basetheta=base_theta) + f" - {survival_range.replace('_', ' ').title()}", 
                             fontsize=config['fontsize_title'])
                    plot_filename = config['filename_semilogy'].format(N=N, steps=steps, samples=samples, basetheta=base_theta)
                elif plot_type == 'loglog':
                    plt.xlabel(config['xlabel'] + " (log scale)", fontsize=config['fontsize_labels'])
                    plt.ylabel(config['ylabel_loglog'], fontsize=config['fontsize_labels'])
                    plt.title(config['title_loglog'].format(basetheta=base_theta) + f" - {survival_range.replace('_', ' ').title()}", 
                             fontsize=config['fontsize_title'])
                    plot_filename = config['filename_loglog'].format(N=N, steps=steps, samples=samples, basetheta=base_theta)
                    plt.grid(True, alpha=config['grid_alpha'], which=config['grid_which'], 
                            linestyle=config['grid_linestyle'])
                else:
                    plt.grid(True, alpha=config['grid_alpha'])
                
                if plot_type != 'loglog':
                    plt.grid(True, alpha=config['grid_alpha'])
                
                plt.legend(fontsize=config['fontsize_legend'])
                plt.tight_layout()
                
                # Save the plot (if enabled)
                if config['save_figure']:
                    # Ensure the figure save directory exists
                    os.makedirs(FIG_SAVE_PATH, exist_ok=True)
                    # Insert survival range into filename
                    base_name, ext = os.path.splitext(plot_filename)
                    plot_filename_with_range = f"{base_name}_{survival_range}{ext}"
                    full_plot_path = os.path.join(FIG_SAVE_PATH, plot_filename_with_range)
                    plt.savefig(full_plot_path, dpi=config['dpi'], bbox_inches=config['bbox_inches'])
                    print(f"[OK] Dynamic survival probability plot saved as '{full_plot_path}'")
                
                # Show the plot
                plt.show()
                
            saved_status = " and saved" if config['save_figure'] else ""
            scale_info = f" ({', '.join(plot_types)} scale{'s' if len(plot_types) > 1 else ''})"
            print(f"[OK] Dynamic survival probability plot{scale_info} displayed{saved_status}!")
        else:
            print("[WARNING] No dynamic survival probability data available for plotting")
    except Exception as e:
        print(f"[WARNING] Could not create dynamic survival probability plot: {e}")
        import traceback
        traceback.print_exc()

# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main():
    """
    Main function that loads data and creates plots.
    """
    print("="*80)
    print("DYNAMIC QUANTUM WALK EXPERIMENT - COMPREHENSIVE PLOTTING")
    print("="*80)
    print(f"System size: N = {N}")
    print(f"Time steps: {steps}")
    print(f"Samples per deviation: {samples}")
    print(f"Deviation values: {devs}")
    print(f"Base theta parameter: {base_theta:.6f}")
    print("")
    
    print("Configuration:")
    print(f"  ENABLE_PLOTTING = {ENABLE_PLOTTING}")
    print(f"  STD_PLOT enabled = {STD_PLOT_CONFIG['enabled']}")
    print(f"  STD_PLOT use_loglog = {STD_PLOT_CONFIG['use_loglog']}")
    print(f"  PROBDIST_PLOT enabled = {PROBDIST_PLOT_CONFIG['enabled']}")
    print(f"  SURVIVAL_PLOT enabled = {SURVIVAL_PLOT_CONFIG['enabled']}")
    print(f"  SURVIVAL_PLOT use_semilogy = {SURVIVAL_PLOT_CONFIG['use_semilogy']}")
    print(f"  SURVIVAL_PLOT use_loglog = {SURVIVAL_PLOT_CONFIG['use_loglog']}")
    print(f"  SURVIVAL_PLOT range = {SURVIVAL_PLOT_CONFIG['survival_range']}")
    print(f"  Save figures = {all([STD_PLOT_CONFIG['save_figure'], PROBDIST_PLOT_CONFIG['save_figure'], SURVIVAL_PLOT_CONFIG['save_figure']])}")
    print("")
    
    # Step 1: Load dynamic standard deviation data
    print("[STEP 1] Loading dynamic standard deviation data...")
    try:
        stds = load_dynamic_std_data_directly(devs, N, base_theta, STD_BASE_DIR, samples)
        print(f"[OK] Dynamic standard deviation data ready for {len([s for s in stds if len(s) > 0])} / {len(devs)} deviations")
    except Exception as e:
        print(f"[ERROR] Failed to load dynamic standard deviation data: {e}")
        stds = []
    
    # Step 2: Load final step probability distributions (only if needed for plotting)
    final_results = []
    if PROBDIST_PLOT_CONFIG['enabled']:
        print("[STEP 2] Loading dynamic final step probability distributions...")
        try:
            final_results = load_dynamic_final_step_probability_distributions(
                N, base_theta, steps, devs, PROBDIST_BASE_DIR, samples
            )
            print(f"[OK] Loaded dynamic final step distributions for {len([r for r in final_results if r is not None])} / {len(devs)} deviations")
        except Exception as e:
            print(f"[ERROR] Failed to load dynamic final step probability distributions: {e}")
            final_results = []
    else:
        print("[STEP 2] Skipping dynamic final step probability distributions (PROBDIST_PLOT disabled)")
    
    # Step 3: Load survival probability data (only if needed for plotting)
    survival_probs = []
    if SURVIVAL_PLOT_CONFIG['enabled']:
        print("[STEP 3] Loading dynamic survival probability data...")
        try:
            survival_range = SURVIVAL_PLOT_CONFIG['survival_range']
            survival_probs = load_dynamic_survival_probability_data(
                devs, N, base_theta, SURVIVAL_BASE_DIR, survival_range, samples
            )
            print(f"[OK] Prepared dynamic survival probabilities for {len([s for s in survival_probs if len(s) > 0])} / {len(devs)} deviations")
        except Exception as e:
            print(f"[ERROR] Failed to load dynamic survival probability data: {e}")
            import traceback
            traceback.print_exc()
            survival_probs = []
    else:
        print("[STEP 3] Skipping dynamic survival probability data (SURVIVAL_PLOT disabled)")
    
    # Step 4: Create plots
    print("[STEP 4] Creating dynamic plots...")
    
    # Plot 1: Dynamic standard deviation vs time
    plot_dynamic_standard_deviation_vs_time(stds, devs, steps)
    
    # Plot 2: Dynamic final probability distributions
    plot_dynamic_final_probability_distributions(final_results, devs, steps, N)
    
    # Plot 3: Dynamic survival probabilities
    if SURVIVAL_PLOT_CONFIG['enabled'] and survival_probs:
        survival_range = SURVIVAL_PLOT_CONFIG['survival_range']
        plot_dynamic_survival_probabilities(survival_probs, devs, steps, survival_range)
    
    print("\n" + "="*80)
    print("DYNAMIC PLOTTING COMPLETED!")
    print("="*80)

if __name__ == "__main__":
    main()
