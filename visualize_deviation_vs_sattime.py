#!/usr/bin/env python3

"""
Collect and Visualize Deviation vs Saturation Time Results

This script reads all the saturation time results generated by the linspace sattime script
and creates a comprehensive plot showing the relationship between deviation values and
their corresponding saturation times.
"""

import os
import pickle
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import glob

def collect_saturation_results(base_dir="experiments_data_samples_linspace_sattime", 
                             N=4000, theta=np.pi/3):
    """
    Collect all saturation time results from the directory structure.
    
    Args:
        base_dir: Base directory containing saturation time results
        N: System size to look for
        theta: Theta parameter value
    
    Returns:
        tuple: (deviations, saturation_times, saturation_values, metadata_list)
    """
    print(f"Collecting saturation results from: {base_dir}")
    print(f"Looking for N={N}, theta={theta:.6f}")
    
    # Format directory path
    theta_folder = f"theta_{theta:.6f}"
    search_dir = os.path.join(base_dir, "static_noise_linspace", f"N_{N}", theta_folder)
    
    print(f"Search directory: {search_dir}")
    
    if not os.path.exists(search_dir):
        print(f"Search directory does not exist!")
        return [], [], [], []
    
    deviations = []
    saturation_times = []
    saturation_values = []
    metadata_list = []
    
    # Look for all dev_ directories
    dev_pattern = os.path.join(search_dir, "dev_*")
    dev_dirs = glob.glob(dev_pattern)
    
    print(f"Found {len(dev_dirs)} deviation directories")
    
    for dev_dir in sorted(dev_dirs):
        sattime_file = os.path.join(dev_dir, "saturation_time.pkl")
        
        if os.path.exists(sattime_file):
            try:
                with open(sattime_file, 'rb') as f:
                    data = pickle.load(f)
                
                # Extract deviation value from directory name
                dev_folder_name = os.path.basename(dev_dir)
                if dev_folder_name.startswith("dev_min"):
                    # Format: dev_min0.000_max0.600
                    parts = dev_folder_name.replace("dev_min", "").split("_max")
                    if len(parts) == 2:
                        dev_min = float(parts[0])
                        dev_max = float(parts[1])
                        deviation = dev_max  # Use max value as the deviation
                    else:
                        continue
                elif dev_folder_name.startswith("dev_"):
                    # Format: dev_0.600
                    deviation = float(dev_folder_name.replace("dev_", ""))
                else:
                    continue
                
                sat_time = data.get('saturation_time', np.nan)
                sat_value = data.get('saturation_value', np.nan)
                metadata = data.get('metadata', {})
                
                deviations.append(deviation)
                saturation_times.append(sat_time)
                saturation_values.append(sat_value)
                metadata_list.append(metadata)
                
                print(f"  {dev_folder_name}: deviation={deviation:.3f}, sat_time={sat_time:.2f}, sat_value={sat_value:.4f}")
                
            except Exception as e:
                print(f"  Error reading {sattime_file}: {e}")
        else:
            print(f"  Missing saturation file: {sattime_file}")
    
    print(f"\nCollected {len(deviations)} results")
    return deviations, saturation_times, saturation_values, metadata_list

def plot_deviation_vs_saturation(deviations, saturation_times, saturation_values, metadata_list, 
                                N=4000, theta=np.pi/3, save_file="deviation_vs_saturation_time.png"):
    """
    Create comprehensive plots showing deviation vs saturation time relationships.
    """
    
    # Convert to numpy arrays
    deviations = np.array(deviations)
    saturation_times = np.array(saturation_times)
    saturation_values = np.array(saturation_values)
    
    # Filter out invalid results
    valid_mask = (~np.isnan(saturation_times)) & (~np.isnan(saturation_values)) & (saturation_times > 0)
    
    if np.sum(valid_mask) == 0:
        print("No valid saturation times found!")
        return
    
    dev_valid = deviations[valid_mask]
    sat_times_valid = saturation_times[valid_mask]
    sat_values_valid = saturation_values[valid_mask]
    metadata_valid = [metadata_list[i] for i in range(len(metadata_list)) if valid_mask[i]]
    
    print(f"Plotting {len(dev_valid)} valid results out of {len(deviations)} total")
    
    # Create comprehensive figure
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))
    
    # Main plot: Deviation vs Saturation Time
    ax1 = axes[0, 0]
    ax1.plot(dev_valid, sat_times_valid, 'bo-', markersize=8, linewidth=2, label='Detected Saturation Times')
    ax1.set_xlabel('Deviation Value')
    ax1.set_ylabel('Saturation Time')
    ax1.set_title('MAIN RESULT: Deviation vs Saturation Time')
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    
    # Add trend line if enough points
    if len(dev_valid) > 3:
        try:
            # Fit polynomial
            poly_coeffs = np.polyfit(dev_valid, sat_times_valid, min(3, len(dev_valid)-1))
            poly_fit = np.poly1d(poly_coeffs)
            dev_smooth = np.linspace(dev_valid.min(), dev_valid.max(), 100)
            ax1.plot(dev_smooth, poly_fit(dev_smooth), 'r--', alpha=0.7, label=f'Polynomial Fit (degree {len(poly_coeffs)-1})')
            ax1.legend()
        except:
            pass
    
    # Plot 2: Deviation vs Saturation Value
    ax2 = axes[0, 1]
    ax2.plot(dev_valid, sat_values_valid, 'go-', markersize=8, linewidth=2, label='Saturation Values')
    ax2.set_xlabel('Deviation Value')
    ax2.set_ylabel('Saturation Value (Final Std)')
    ax2.set_title('Deviation vs Saturation Value')
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    
    # Plot 3: Saturation Time vs Saturation Value
    ax3 = axes[0, 2]
    scatter = ax3.scatter(sat_times_valid, sat_values_valid, c=dev_valid, cmap='viridis', s=80)
    ax3.set_xlabel('Saturation Time')
    ax3.set_ylabel('Saturation Value')
    ax3.set_title('Saturation Time vs Value\n(colored by deviation)')
    ax3.grid(True, alpha=0.3)
    plt.colorbar(scatter, ax=ax3, label='Deviation')
    
    # Plot 4: Detection success rate and statistics
    ax4 = axes[1, 0]
    total_deviations = len(deviations)
    successful_detections = len(dev_valid)
    failed_detections = total_deviations - successful_detections
    
    labels = ['Successful\nDetections', 'Failed\nDetections']
    sizes = [successful_detections, failed_detections]
    colors = ['lightgreen', 'lightcoral']
    
    ax4.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
    ax4.set_title(f'Detection Success Rate\n({successful_detections}/{total_deviations} successful)')
    
    # Plot 5: Distribution of saturation times
    ax5 = axes[1, 1]
    if len(sat_times_valid) > 1:
        ax5.hist(sat_times_valid, bins=min(20, len(sat_times_valid)//2), alpha=0.7, color='blue', edgecolor='black')
        ax5.axvline(np.mean(sat_times_valid), color='red', linestyle='--', label=f'Mean: {np.mean(sat_times_valid):.1f}')
        ax5.axvline(np.median(sat_times_valid), color='green', linestyle='--', label=f'Median: {np.median(sat_times_valid):.1f}')
    ax5.set_xlabel('Saturation Time')
    ax5.set_ylabel('Frequency')
    ax5.set_title('Distribution of Saturation Times')
    ax5.legend()
    ax5.grid(True, alpha=0.3)
    
    # Plot 6: Summary statistics and metadata
    ax6 = axes[1, 2]
    ax6.axis('off')
    
    # Calculate statistics
    if len(sat_times_valid) > 0:
        stats_text = f"""
EXPERIMENT PARAMETERS:
• System size (N): {N}
• Theta: {theta:.6f} ({theta/np.pi:.3f}π)
• Total deviations tested: {total_deviations}
• Successful detections: {successful_detections}
• Success rate: {successful_detections/total_deviations*100:.1f}%

SATURATION TIME STATISTICS:
• Range: {np.min(sat_times_valid):.1f} - {np.max(sat_times_valid):.1f}
• Mean: {np.mean(sat_times_valid):.1f} ± {np.std(sat_times_valid):.1f}
• Median: {np.median(sat_times_valid):.1f}

SATURATION VALUE STATISTICS:
• Range: {np.min(sat_values_valid):.3f} - {np.max(sat_values_valid):.3f}
• Mean: {np.mean(sat_values_valid):.3f} ± {np.std(sat_values_valid):.3f}
• Median: {np.median(sat_values_valid):.3f}

ALGORITHM METADATA (from first valid result):
"""
        if metadata_valid:
            first_meta = metadata_valid[0]
            stats_text += f"• Smoothing method: {first_meta.get('smoothing_method', 'N/A')}\n"
            eps_val = first_meta.get('eps', 'N/A')
            if isinstance(eps_val, (int, float)):
                stats_text += f"• Threshold (ε): {eps_val:.4f}\n"
            else:
                stats_text += f"• Threshold (ε): {eps_val}\n"
            stats_text += f"• Window size: {first_meta.get('window', 'N/A')}\n"
            stats_text += f"• Run length: {first_meta.get('run_length', 'N/A')}\n"
        
        stats_text += f"\nGenerated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    else:
        stats_text = "No valid results to display statistics."
    
    ax6.text(0.05, 0.95, stats_text, transform=ax6.transAxes, fontfamily='monospace', 
             fontsize=10, verticalalignment='top')
    
    plt.suptitle(f'Saturation Time Analysis Results (N={N}, θ={theta:.3f}π)', fontsize=16, fontweight='bold')
    plt.tight_layout()
    plt.savefig(save_file, dpi=150, bbox_inches='tight')
    plt.show()
    
    print(f"\nPlot saved as: {save_file}")
    
    # Also save results as CSV for further analysis
    csv_file = save_file.replace('.png', '.csv')
    if len(dev_valid) > 0:
        import csv
        with open(csv_file, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['deviation', 'saturation_time', 'saturation_value', 'eps', 'smoothing_method'])
            for i in range(len(dev_valid)):
                meta = metadata_valid[i] if i < len(metadata_valid) else {}
                writer.writerow([
                    dev_valid[i], 
                    sat_times_valid[i], 
                    sat_values_valid[i],
                    meta.get('eps', ''),
                    meta.get('smoothing_method', '')
                ])
        print(f"Results also saved as CSV: {csv_file}")
    
    return dev_valid, sat_times_valid, sat_values_valid

def main():
    """Main function to collect and plot results."""
    
    print("=== DEVIATION vs SATURATION TIME VISUALIZATION ===")
    
    # You can modify these parameters to match your experiment
    N = 4000
    theta = np.pi/3
    base_dir = "experiments_data_samples_linspace_sattime"
    
    # Collect results
    deviations, saturation_times, saturation_values, metadata_list = collect_saturation_results(
        base_dir=base_dir, N=N, theta=theta
    )
    
    if len(deviations) == 0:
        print("No results found! Make sure to run generate_linspace_sattime_from_std.py first.")
        return
    
    # Create plots
    results = plot_deviation_vs_saturation(
        deviations, saturation_times, saturation_values, metadata_list,
        N=N, theta=theta, save_file="deviation_vs_saturation_time.png"
    )
    
    if results is not None:
        dev_valid, sat_times_valid, sat_values_valid = results
        print(f"\n=== SUMMARY ===")
        print(f"Successfully processed {len(dev_valid)} out of {len(deviations)} deviations")
        if len(sat_times_valid) > 0:
            print(f"Saturation time range: {np.min(sat_times_valid):.1f} - {np.max(sat_times_valid):.1f}")
            print(f"Average saturation time: {np.mean(sat_times_valid):.1f} ± {np.std(sat_times_valid):.1f}")

if __name__ == "__main__":
    main()
