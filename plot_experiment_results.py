#!/usr/bin/env python3

"""
Comprehensive Plotting Script for Quantum Walk Experiment Data

This script loads and plots data generated by the sample generation, probability distribution recreation,
standard deviation generation, and survival probability generation scripts.

Key Features:
- Loads data from the new directory structure used by the generation scripts
- Creates three main plot types: standard deviation vs time, final probability distributions, survival probabilities
- Configurable plot parameters and output formats
- Support for multiple plot scales (linear, log-log, semi-log)
- Smart data loading with flexible directory format support

Usage:
    python plot_experiment_results.py

Configuration:
    Edit the parameters section below to match your experiment setup and plotting preferences.
"""

import os
import sys
import time
import pickle
import logging
import math
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# ============================================================================
# CONFIGURATION PARAMETERS
# ============================================================================

# Experiment parameters - EDIT THESE TO MATCH YOUR SETUP
N = 20000                # System size
steps = N//4           # Time steps
samples = 5           # Samples per deviation
theta = math.pi     # Theta parameter for static noise

# Deviation values - TEST SET (matching other scripts)
devs = [
    (0,0),              # No noise
    (0, 0.2),           # Small noise range
    (0, 0.6),           # Medium noise range  
    (0, 0.8),           # Medium noise range  
    (0, 1),           # Medium noise range  
]
# Directory configuration (matching the generation scripts)
PROBDIST_BASE_DIR = "experiments_data_samples_probDist"
STD_BASE_DIR = "experiments_data_samples_std"
SURVIVAL_BASE_DIR = "experiments_data_samples_survival"

# Global plotting control
ENABLE_PLOTTING = True  # Master switch for all plotting

# Standard Deviation vs Time Plot Configuration
STD_PLOT_CONFIG = {
    'enabled': True,                    # Enable/disable this specific plot
    'use_loglog': True,                 # Use log-log scale instead of linear
    'figure_size': (12, 8),            # Figure size in inches (width, height)
    'save_figure': True,                # Save plot to file
    'filename_linear': 'std_vs_time_N{N}_steps{steps}_samples{samples}_theta{theta:.3f}.png',
    'filename_loglog': 'std_vs_time_loglog_N{N}_steps{steps}_samples{samples}_theta{theta:.3f}.png',
    'title_linear': 'Standard Deviation vs Time for Different Static Noise Deviations',
    'title_loglog': 'Standard Deviation vs Time (Log-Log Scale) for Different Static Noise Deviations',
    'xlabel': 'Time Step',
    'ylabel': 'Standard Deviation',
    'fontsize_title': 14,
    'fontsize_labels': 12,
    'fontsize_legend': 10,
    'linewidth': 2,
    'markersize': 0,
    'marker_circle': 'o',
    'marker_square': 's',
    'marker_square_size': 4,
    'linestyle_noiseless': '--',
    'alpha_noiseless': 0.8,
    'alpha_regular': 1.0,
    'grid_alpha': 0.3,
    'grid_which': 'both',               # For log-log: 'both', 'major', 'minor'
    'grid_linestyle': '-',
    'epsilon_noiseless': 1e-3,          # Small value for noiseless case in log-log
    'dpi': 300,                         # DPI for saved figures
    'bbox_inches': 'tight'              # Bbox setting for saved figures
}

# Final Probability Distribution Plot Configuration  
PROBDIST_PLOT_CONFIG = {
    'enabled': True,                    # Enable/disable this specific plot
    'figure_size': (14, 8),            # Figure size in inches (width, height)
    'save_figure': True,                # Save plot to file
    'filename': 'final_probdist_log_N{N}_steps{steps}_samples{samples}_theta{theta:.3f}.png',
    'title': 'Probability Distributions at Final Time Step (t={final_step}) - Log Scale',
    'xlabel': 'Position',
    'ylabel': 'Probability (log scale)',
    'fontsize_title': 14,
    'fontsize_labels': 12,
    'fontsize_legend': 10,
    'linewidth': 2,
    'alpha': 0.8,
    'xlim': (-80, 80),                 # X-axis limits
    'ylim_min': 1e-5,                  # Y-axis minimum (None for auto)
    'ylim_max': 1e0,                   # Y-axis maximum (None for auto)
    'grid_alpha': 0.3,
    'dpi': 300,                        # DPI for saved figures
    'bbox_inches': 'tight'             # Bbox setting for saved figures
}

# Survival Probability Plot Configuration
SURVIVAL_PLOT_CONFIG = {
    'enabled': True,                    # Enable/disable this specific plot
    'use_loglog': True,                # Use log-log scale instead of linear
    'use_semilogy': True,              # Use log-linear (semilogy) scale
    'figure_size': (12, 8),            # Figure size in inches (width, height)
    'save_figure': True,                # Save plot to file
    'filename_linear': 'survival_prob_linear_N{N}_steps{steps}_samples{samples}_theta{theta:.3f}.png',
    'filename_loglog': 'survival_prob_loglog_N{N}_steps{steps}_samples{samples}_theta{theta:.3f}.png',
    'filename_semilogy': 'survival_prob_semilogy_N{N}_steps{steps}_samples{samples}_theta{theta:.3f}.png',
    'title_linear': 'Survival Probability vs Time for Different Static Noise Deviations',
    'title_loglog': 'Survival Probability vs Time (Log-Log Scale) for Different Static Noise Deviations',
    'title_semilogy': 'Survival Probability vs Time (Semi-Log Scale) for Different Static Noise Deviations',
    'xlabel': 'Time Step',
    'ylabel_linear': 'Survival Probability',
    'ylabel_loglog': 'Survival Probability (log scale)',
    'ylabel_semilogy': 'Survival Probability (log scale)',
    'fontsize_title': 14,
    'fontsize_labels': 12,
    'fontsize_legend': 10,
    'linewidth': 2,
    'markersize': 0,
    'alpha_regular': 1.0,
    'grid_alpha': 0.3,
    'grid_which': 'both',               # For log-log: 'both', 'major', 'minor'
    'grid_linestyle': '-',
    'dpi': 300,                         # DPI for saved figures
    'bbox_inches': 'tight',             # Bbox setting for saved figures
    'survival_range': 'center'          # Default survival range to plot
}

# Label formatting configuration
LABEL_CONFIG = {
    'precision_new_format': 3,          # Decimal places for new format labels
    'precision_legacy_format': 3,       # Decimal places for legacy format labels
    'precision_single_value': 3,        # Decimal places for single value labels
    'plot_label_template': 'Static deviation = {dev_label}'
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def dummy_tesselation_func(N):
    """Dummy tessellation function for static noise (tessellations are built-in)"""
    return None

def format_deviation_label(dev):
    """
    Format deviation values for plot labels.
    """
    if isinstance(dev, (tuple, list)) and len(dev) == 2:
        min_val, max_val = dev
        if max_val == 0:
            return "0.000"
        else:
            return f"({min_val:.3f}, {max_val:.3f})"
    else:
        return f"{float(dev):.3f}"

def get_experiment_dir(tesselation_func, has_noise, N, noise_params=None, noise_type="static_noise", base_dir="experiments_data_samples", theta=None, samples=None):
    """
    Get experiment directory path with proper structure.
    
    Structure: base_dir/tesselation_func_noise_type/theta_value/dev_range/N_value/samples_count
    Example: experiments_data_samples_probDist/dummy_tesselation_func_static_noise/theta_1.047198/dev_min0.000_max0.000/N_20000/samples_40
    """
    # Handle deviation format
    if noise_params and len(noise_params) > 0:
        dev = noise_params[0]
        if isinstance(dev, (tuple, list)) and len(dev) == 2:
            min_val, max_val = dev
            dev_str = f"dev_min{min_val:.3f}_max{max_val:.3f}"
        else:
            dev_str = f"dev_{float(dev):.3f}"
    else:
        dev_str = "dev_min0.000_max0.000"
    
    # Format theta for directory
    if theta is not None:
        theta_str = f"theta_{theta:.6f}"
    else:
        theta_str = "theta_default"
    
    # Format tessellation function name for directory
    if tesselation_func is None or hasattr(tesselation_func, '__name__') and tesselation_func.__name__ == 'dummy_tesselation_func':
        tessellation_name = "dummy_tesselation_func"
    else:
        tessellation_name = getattr(tesselation_func, '__name__', 'unknown_tesselation_func')
    
    # Build directory path with correct structure
    exp_dir = os.path.join(
        base_dir,
        f"{tessellation_name}_{noise_type}",
        theta_str,
        dev_str,
        f"N_{N}"
    )
    
    if samples is not None:
        exp_dir = os.path.join(exp_dir, f"samples_{samples}")
    
    return exp_dir

def find_experiment_dir_flexible(tesselation_func, has_noise, N, noise_params=None, noise_type="static_noise", base_dir="experiments_data_samples", theta=None):
    """
    Find experiment directory with flexible format matching.
    Tries different directory structures to find existing data.
    """
    # Try new format first (with and without samples in path)
    for samples_try in [40, 20, 10, 5, None]:  # Common sample counts
        exp_dir = get_experiment_dir(tesselation_func, has_noise, N, noise_params, noise_type, base_dir, theta, samples_try)
        if os.path.exists(exp_dir):
            return exp_dir, "new_format"
    
    # Try old format variations for backwards compatibility
    if noise_params and len(noise_params) > 0:
        dev = noise_params[0]
        if isinstance(dev, (tuple, list)) and len(dev) == 2:
            min_val, max_val = dev
            dev_str = f"min{min_val:.3f}_max{max_val:.3f}"
        else:
            dev_str = f"{float(dev):.3f}"
    else:
        dev_str = "0.000"
    
    # Try various old format possibilities
    old_formats = [
        os.path.join(base_dir, f"N_{N}", f"static_dev_{dev_str}"),
        os.path.join(base_dir, f"N_{N}", f"dev_{dev_str}"),
        os.path.join(base_dir, f"static_dev_{dev_str}", f"N_{N}"),
    ]
    
    for exp_dir in old_formats:
        if os.path.exists(exp_dir):
            return exp_dir, "old_format"
    
    # If nothing found, return the new format path (will be created if needed)
    return get_experiment_dir(tesselation_func, has_noise, N, noise_params, noise_type, base_dir, theta, None), "new_format"

# ============================================================================
# DATA LOADING FUNCTIONS
# ============================================================================

def load_std_data_directly(devs, N, tesselation_func, std_base_dir, noise_type, theta=None):
    """
    Load standard deviation data directly from std files.
    """
    print(f"\n[DATA] Loading standard deviation data from '{std_base_dir}'...")
    
    stds = []
    
    for i, dev in enumerate(devs):
        # Handle deviation format for has_noise check
        if isinstance(dev, (tuple, list)) and len(dev) == 2:
            min_val, max_val = dev
            has_noise = max_val > 0
        else:
            has_noise = dev > 0
        
        # Get experiment directory
        noise_params = [dev]
        exp_dir, format_type = find_experiment_dir_flexible(
            tesselation_func, has_noise, N, 
            noise_params=noise_params, noise_type=noise_type, 
            base_dir=std_base_dir, theta=theta
        )
        
        std_file = os.path.join(exp_dir, "std_vs_time.pkl")
        
        try:
            if os.path.exists(std_file):
                with open(std_file, 'rb') as f:
                    std_data = pickle.load(f)
                stds.append(std_data)
                print(f"  Dev {format_deviation_label(dev)}: {len(std_data)} time steps")
            else:
                print(f"  Dev {format_deviation_label(dev)}: file not found - {std_file}")
                stds.append([])
        except Exception as e:
            print(f"  Dev {format_deviation_label(dev)}: load error - {e}")
            stds.append([])
    
    print(f"[OK] Standard deviation data loading completed!")
    return stds

def load_final_step_probability_distributions(tesselation_func, N, steps, parameter_list, probdist_base_dir, noise_type, theta):
    """
    Load only the final step probability distributions from the probDist folder.
    """
    final_step = steps - 1
    print(f"\n[DATA] Loading final step probability distributions (step {final_step}) from '{probdist_base_dir}'...")
    
    results = []
    for i, dev in enumerate(parameter_list):
        # Handle deviation format for has_noise check
        if isinstance(dev, (tuple, list)) and len(dev) == 2:
            min_val, max_val = dev
            has_noise = max_val > 0
        else:
            has_noise = dev > 0
        
        # Get experiment directory
        noise_params = [dev]
        exp_dir, format_type = find_experiment_dir_flexible(
            tesselation_func, has_noise, N, 
            noise_params=noise_params, noise_type=noise_type, 
            base_dir=probdist_base_dir, theta=theta
        )
        
        prob_file = os.path.join(exp_dir, f"mean_step_{final_step}.pkl")
        
        try:
            if os.path.exists(prob_file):
                with open(prob_file, 'rb') as f:
                    prob_data = pickle.load(f)
                results.append(prob_data)
                print(f"  Dev {format_deviation_label(dev)}: loaded final step distribution")
            else:
                print(f"  Dev {format_deviation_label(dev)}: file not found - {prob_file}")
                results.append(None)
        except Exception as e:
            print(f"  Dev {format_deviation_label(dev)}: load error - {e}")
            results.append(None)
    
    print(f"[OK] Final step probability distribution loading completed!")
    return results

def load_survival_probability_data(devs, N, tesselation_func, survival_base_dir, noise_type, theta=None, survival_range="center"):
    """
    Load survival probability data directly from survival probability files.
    """
    print(f"\n[DATA] Loading survival probability data from '{survival_base_dir}'...")
    print(f"[DATA] Target survival range: {survival_range}")
    
    survival_probs = []
    
    for i, dev in enumerate(devs):
        # Handle deviation format for has_noise check
        if isinstance(dev, (tuple, list)) and len(dev) == 2:
            min_val, max_val = dev
            has_noise = max_val > 0
        else:
            has_noise = dev > 0
        
        # Get experiment directory
        noise_params = [dev]
        exp_dir, format_type = find_experiment_dir_flexible(
            tesselation_func, has_noise, N, 
            noise_params=noise_params, noise_type=noise_type, 
            base_dir=survival_base_dir, theta=theta
        )
        
        survival_file = os.path.join(exp_dir, "survival_vs_time.pkl")
        
        try:
            if os.path.exists(survival_file):
                with open(survival_file, 'rb') as f:
                    survival_data = pickle.load(f)
                
                # Extract data for the requested range
                if isinstance(survival_data, dict) and survival_range in survival_data:
                    range_data = survival_data[survival_range]
                    survival_probs.append(range_data)
                    print(f"  Dev {format_deviation_label(dev)}: {len(range_data)} time steps for range '{survival_range}'")
                else:
                    print(f"  Dev {format_deviation_label(dev)}: range '{survival_range}' not found in data")
                    survival_probs.append([])
            else:
                print(f"  Dev {format_deviation_label(dev)}: file not found - {survival_file}")
                survival_probs.append([])
        except Exception as e:
            print(f"  Dev {format_deviation_label(dev)}: load error - {e}")
            survival_probs.append([])
    
    print(f"[OK] Survival probability data loading completed!")
    return survival_probs

# ============================================================================
# PLOTTING FUNCTIONS
# ============================================================================

def plot_standard_deviation_vs_time(stds, devs, steps):
    """
    Plot standard deviation vs time for different noise deviations.
    """
    config = STD_PLOT_CONFIG
    if not ENABLE_PLOTTING or not config['enabled']:
        print("\n[PLOT] Standard deviation plotting disabled")
        return
    
    print("\n[PLOT] Creating standard deviation vs time plot...")
    try:
        if len(stds) > 0 and any(len(s) > 0 for s in stds):
            plt.figure(figsize=config['figure_size'])
            
            for i, (std_values, dev) in enumerate(zip(stds, devs)):
                if len(std_values) > 0:
                    time_steps = list(range(len(std_values)))
                    dev_label = format_deviation_label(dev)
                    plot_label = LABEL_CONFIG['plot_label_template'].format(dev_label=dev_label)
                    
                    if config['use_loglog']:
                        # Remove zero values which can't be plotted on log scale
                        filtered_data = [(t, s) for t, s in zip(time_steps, std_values) if t > 0 and s > 0]
                        if filtered_data:
                            filtered_times, filtered_stds = zip(*filtered_data)
                            
                            # Special styling for noiseless case
                            if isinstance(dev, (tuple, list)) and dev[1] == 0:
                                plt.loglog(filtered_times, filtered_stds, 
                                         label=f'{plot_label} (noiseless)', 
                                         marker=config['marker_square'], markersize=config['marker_square_size'], 
                                         linewidth=config['linewidth'], 
                                         linestyle=config['linestyle_noiseless'], alpha=config['alpha_noiseless'])
                            else:
                                plt.loglog(filtered_times, filtered_stds, 
                                         label=plot_label, 
                                         marker=config['marker_circle'], markersize=config['markersize'], 
                                         linewidth=config['linewidth'], alpha=config['alpha_regular'])
                    else:
                        plt.plot(time_steps, std_values, 
                               label=plot_label, 
                               marker=config['marker_circle'], markersize=config['markersize'], 
                               linewidth=config['linewidth'], alpha=config['alpha_regular'])
            
            plt.xlabel(config['xlabel'], fontsize=config['fontsize_labels'])
            plt.ylabel(config['ylabel'], fontsize=config['fontsize_labels'])
            
            if config['use_loglog']:
                plt.title(config['title_loglog'], fontsize=config['fontsize_title'])
                plt.grid(True, alpha=config['grid_alpha'], which=config['grid_which'], 
                        linestyle=config['grid_linestyle'])
                plot_filename = config['filename_loglog'].format(N=N, steps=steps, samples=samples, theta=theta)
            else:
                plt.title(config['title_linear'], fontsize=config['fontsize_title'])
                plt.grid(True, alpha=config['grid_alpha'])
                plot_filename = config['filename_linear'].format(N=N, steps=steps, samples=samples, theta=theta)
            
            plt.legend(fontsize=config['fontsize_legend'])
            plt.tight_layout()
            
            # Save the plot (if enabled)
            if config['save_figure']:
                plt.savefig(plot_filename, dpi=config['dpi'], bbox_inches=config['bbox_inches'])
                print(f"[OK] Plot saved as '{plot_filename}'")
            
            # Show the plot
            plt.show()
            plot_type = "log-log" if config['use_loglog'] else "linear"
            saved_status = " and saved" if config['save_figure'] else ""
            print(f"[OK] Standard deviation plot displayed{saved_status}! (Scale: {plot_type})")
        else:
            print("[WARNING] No standard deviation data available for plotting")
    except Exception as e:
        print(f"[WARNING] Could not create plot: {e}")
        import traceback
        traceback.print_exc()

def plot_final_probability_distributions(final_results, devs, steps, N):
    """
    Plot final probability distributions for different noise deviations.
    """
    config = PROBDIST_PLOT_CONFIG
    if not ENABLE_PLOTTING or not config['enabled']:
        print("\n[PLOT] Final probability distribution plotting disabled")
        return
    
    print("\n[PLOT] Creating final probability distribution plot...")
    try:
        if final_results and len(final_results) > 0:
            plt.figure(figsize=config['figure_size'])
            
            # Use the last time step (steps-1)
            final_step = steps - 1
            domain = np.arange(N) - N//2  # Center domain around 0
            
            for i, (final_prob_dist, dev) in enumerate(zip(final_results, devs)):
                if final_prob_dist is not None:
                    final_prob_dist = final_prob_dist.flatten()
                    
                    dev_label = format_deviation_label(dev)
                    plot_label = LABEL_CONFIG['plot_label_template'].format(dev_label=dev_label)
                    
                    # Plot the probability distribution with log y-axis
                    plt.semilogy(domain, final_prob_dist, 
                               label=plot_label, 
                               linewidth=config['linewidth'], alpha=config['alpha'])
            
            plt.xlabel(config['xlabel'], fontsize=config['fontsize_labels'])
            plt.ylabel(config['ylabel'], fontsize=config['fontsize_labels'])
            plt.title(config['title'].format(final_step=final_step), fontsize=config['fontsize_title'])
            
            # Set axis limits based on config
            if config['xlim']:
                plt.xlim(config['xlim'])
            if config['ylim_min'] is not None or config['ylim_max'] is not None:
                plt.ylim(config['ylim_min'], config['ylim_max'])
            
            plt.legend(fontsize=config['fontsize_legend'])
            plt.grid(True, alpha=config['grid_alpha'])
            plt.tight_layout()
            
            # Save the plot (if enabled)
            if config['save_figure']:
                plot_filename = config['filename'].format(N=N, steps=steps, samples=samples, theta=theta)
                plt.savefig(plot_filename, dpi=config['dpi'], bbox_inches=config['bbox_inches'])
                print(f"[OK] Probability distribution plot saved as '{plot_filename}'")
            
            # Show the plot
            plt.show()
            saved_status = " and saved" if config['save_figure'] else ""
            print(f"[OK] Final probability distribution plot displayed{saved_status}!")
        else:
            print("[WARNING] No probability distribution data available for plotting")
    except Exception as e:
        print(f"[WARNING] Could not create probability distribution plot: {e}")
        import traceback
        traceback.print_exc()

def plot_survival_probabilities(survival_probs, devs, steps, survival_range="center"):
    """
    Plot survival probabilities vs time for different noise deviations.
    """
    config = SURVIVAL_PLOT_CONFIG
    if not ENABLE_PLOTTING or not config['enabled']:
        print("\n[PLOT] Survival probability plotting disabled")
        return
    
    print(f"\n[PLOT] Creating survival probability vs time plot for range '{survival_range}'...")
    try:
        if len(survival_probs) > 0 and any(len(sp) > 0 for sp in survival_probs):
            # Determine which plot types to create
            plot_types = []
            if not config['use_loglog'] and not config['use_semilogy']:
                plot_types.append('linear')
            if config['use_semilogy']:
                plot_types.append('semilogy')
            if config['use_loglog']:
                plot_types.append('loglog')
            
            for plot_type in plot_types:
                plt.figure(figsize=config['figure_size'])
                
                for i, (survival_values, dev) in enumerate(zip(survival_probs, devs)):
                    if len(survival_values) > 0:
                        time_steps = list(range(len(survival_values)))
                        
                        dev_label = format_deviation_label(dev)
                        plot_label = LABEL_CONFIG['plot_label_template'].format(dev_label=dev_label)
                        
                        # Plot based on type
                        if plot_type == 'linear':
                            # Filter out None values even for linear scale
                            filtered_data = [(t, s) for t, s in zip(time_steps, survival_values) if s is not None]
                            if filtered_data:
                                filtered_times, filtered_survival = zip(*filtered_data)
                                plt.plot(filtered_times, filtered_survival, 
                                       label=plot_label, 
                                       linewidth=config['linewidth'], 
                                       alpha=config['alpha_regular'])
                        elif plot_type == 'semilogy':
                            # Filter out zero/negative/None values for log scale
                            filtered_data = [(t, s) for t, s in zip(time_steps, survival_values) if s is not None and s > 0]
                            if filtered_data:
                                filtered_times, filtered_survival = zip(*filtered_data)
                                plt.semilogy(filtered_times, filtered_survival, 
                                           label=plot_label, 
                                           linewidth=config['linewidth'], 
                                           alpha=config['alpha_regular'])
                        elif plot_type == 'loglog':
                            # Filter out zero/negative/None values for log scale
                            filtered_data = [(t, s) for t, s in zip(time_steps, survival_values) if t > 0 and s is not None and s > 0]
                            if filtered_data:
                                filtered_times, filtered_survival = zip(*filtered_data)
                                plt.loglog(filtered_times, filtered_survival, 
                                         label=plot_label, 
                                         linewidth=config['linewidth'], 
                                         alpha=config['alpha_regular'])
                
                # Set labels and title based on plot type
                if plot_type == 'linear':
                    plt.xlabel(config['xlabel'], fontsize=config['fontsize_labels'])
                    plt.ylabel(config['ylabel_linear'], fontsize=config['fontsize_labels'])
                    plt.title(config['title_linear'] + f" - {survival_range.replace('_', ' ').title()}", 
                             fontsize=config['fontsize_title'])
                    plot_filename = config['filename_linear'].format(N=N, steps=steps, samples=samples, theta=theta)
                elif plot_type == 'semilogy':
                    plt.xlabel(config['xlabel'], fontsize=config['fontsize_labels'])
                    plt.ylabel(config['ylabel_semilogy'], fontsize=config['fontsize_labels'])
                    plt.title(config['title_semilogy'] + f" - {survival_range.replace('_', ' ').title()}", 
                             fontsize=config['fontsize_title'])
                    plot_filename = config['filename_semilogy'].format(N=N, steps=steps, samples=samples, theta=theta)
                elif plot_type == 'loglog':
                    plt.xlabel(config['xlabel'] + " (log scale)", fontsize=config['fontsize_labels'])
                    plt.ylabel(config['ylabel_loglog'], fontsize=config['fontsize_labels'])
                    plt.title(config['title_loglog'] + f" - {survival_range.replace('_', ' ').title()}", 
                             fontsize=config['fontsize_title'])
                    plot_filename = config['filename_loglog'].format(N=N, steps=steps, samples=samples, theta=theta)
                    plt.grid(True, alpha=config['grid_alpha'], which=config['grid_which'], 
                            linestyle=config['grid_linestyle'])
                else:
                    plt.grid(True, alpha=config['grid_alpha'])
                
                if plot_type != 'loglog':
                    plt.grid(True, alpha=config['grid_alpha'])
                
                plt.legend(fontsize=config['fontsize_legend'])
                plt.tight_layout()
                
                # Save the plot (if enabled)
                if config['save_figure']:
                    # Insert survival range into filename
                    base_name, ext = os.path.splitext(plot_filename)
                    plot_filename_with_range = f"{base_name}_{survival_range}{ext}"
                    plt.savefig(plot_filename_with_range, dpi=config['dpi'], bbox_inches=config['bbox_inches'])
                    print(f"[OK] Survival probability plot saved as '{plot_filename_with_range}'")
                
                # Show the plot
                plt.show()
                
            saved_status = " and saved" if config['save_figure'] else ""
            scale_info = f" ({', '.join(plot_types)} scale{'s' if len(plot_types) > 1 else ''})"
            print(f"[OK] Survival probability plot{scale_info} displayed{saved_status}!")
        else:
            print("[WARNING] No survival probability data available for plotting")
    except Exception as e:
        print(f"[WARNING] Could not create survival probability plot: {e}")
        import traceback
        traceback.print_exc()

# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main():
    """
    Main function that loads data and creates plots.
    """
    print("="*80)
    print("QUANTUM WALK EXPERIMENT - COMPREHENSIVE PLOTTING")
    print("="*80)
    print(f"System size: N = {N}")
    print(f"Time steps: {steps}")
    print(f"Samples per deviation: {samples}")
    print(f"Deviation values: {devs}")
    print(f"Theta parameter: {theta:.6f}")
    print("")
    
    print("Configuration:")
    print(f"  ENABLE_PLOTTING = {ENABLE_PLOTTING}")
    print(f"  STD_PLOT enabled = {STD_PLOT_CONFIG['enabled']}")
    print(f"  STD_PLOT use_loglog = {STD_PLOT_CONFIG['use_loglog']}")
    print(f"  PROBDIST_PLOT enabled = {PROBDIST_PLOT_CONFIG['enabled']}")
    print(f"  SURVIVAL_PLOT enabled = {SURVIVAL_PLOT_CONFIG['enabled']}")
    print(f"  SURVIVAL_PLOT use_semilogy = {SURVIVAL_PLOT_CONFIG['use_semilogy']}")
    print(f"  SURVIVAL_PLOT use_loglog = {SURVIVAL_PLOT_CONFIG['use_loglog']}")
    print(f"  SURVIVAL_PLOT range = {SURVIVAL_PLOT_CONFIG['survival_range']}")
    print(f"  Save figures = {all([STD_PLOT_CONFIG['save_figure'], PROBDIST_PLOT_CONFIG['save_figure'], SURVIVAL_PLOT_CONFIG['save_figure']])}")
    print("")
    
    # Step 1: Load standard deviation data
    print("[STEP 1] Loading standard deviation data...")
    try:
        stds = load_std_data_directly(devs, N, dummy_tesselation_func, STD_BASE_DIR, "static_noise", theta)
        print(f"[OK] Standard deviation data ready for {len([s for s in stds if len(s) > 0])} / {len(devs)} deviations")
    except Exception as e:
        print(f"[ERROR] Failed to load standard deviation data: {e}")
        stds = []
    
    # Step 2: Load final step probability distributions (only if needed for plotting)
    final_results = []
    if PROBDIST_PLOT_CONFIG['enabled']:
        print("[STEP 2] Loading final step probability distributions...")
        try:
            final_results = load_final_step_probability_distributions(
                dummy_tesselation_func, N, steps, devs, PROBDIST_BASE_DIR, "static_noise", theta
            )
            print(f"[OK] Loaded final step distributions for {len([r for r in final_results if r is not None])} / {len(devs)} deviations")
        except Exception as e:
            print(f"[ERROR] Failed to load final step probability distributions: {e}")
            final_results = []
    else:
        print("[STEP 2] Skipping final step probability distributions (PROBDIST_PLOT disabled)")
    
    # Step 3: Load survival probability data (only if needed for plotting)
    survival_probs = []
    if SURVIVAL_PLOT_CONFIG['enabled']:
        print("[STEP 3] Loading survival probability data...")
        try:
            survival_range = SURVIVAL_PLOT_CONFIG['survival_range']
            survival_probs = load_survival_probability_data(
                devs, N, dummy_tesselation_func, SURVIVAL_BASE_DIR, "static_noise", theta, survival_range
            )
            print(f"[OK] Prepared survival probabilities for {len([s for s in survival_probs if len(s) > 0])} / {len(devs)} deviations")
        except Exception as e:
            print(f"[ERROR] Failed to load survival probability data: {e}")
            import traceback
            traceback.print_exc()
            survival_probs = []
    else:
        print("[STEP 3] Skipping survival probability data (SURVIVAL_PLOT disabled)")
    
    # Step 4: Create plots
    print("[STEP 4] Creating plots...")
    
    # Plot 1: Standard deviation vs time
    plot_standard_deviation_vs_time(stds, devs, steps)
    
    # Plot 2: Final probability distributions
    plot_final_probability_distributions(final_results, devs, steps, N)
    
    # Plot 3: Survival probabilities
    if SURVIVAL_PLOT_CONFIG['enabled'] and survival_probs:
        survival_range = SURVIVAL_PLOT_CONFIG['survival_range']
        plot_survival_probabilities(survival_probs, devs, steps, survival_range)
    
    print("\n" + "="*80)
    print("PLOTTING COMPLETED!")
    print("="*80)

if __name__ == "__main__":
    main()
